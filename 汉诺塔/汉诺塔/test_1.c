#define _CRT_SECURE_NO_WARNINGS 1
/*
汉诺塔问题模式：有三个柱子，每个柱子都可以放圆盘。
从左向右依次起名A柱子、B柱子、C柱子。
现在A柱子有n个大小从下往上依次减小的圆盘，每次可以移动一个盘子，
且大盘不能在小盘上面，最终这n个盘子均移动到C柱子上请输出n个盘子的移动的过程。
*/
/*
思路：
	A	B	C
有1个盘子时：	2^1 - 1次  A->C
有2个盘子时： 	2^2 - 1次  A->B A->C C->B
有3个盘子时：	2^3 - 1次  A->C A->B C->B A->C B->A B->C A->C
采用递归思想：
初始柱子、目标柱子、中间柱子是相对具体的盘子而言的，但最终所有的盘子均要
按规则移动到C盘之上。

求n个盘子过程，先把初始柱子上除最底下的盘子之外的n-1个盘子看做一个整体，
1.类似于初始住上只有2个盘子的情况，
对于上面的n-1个盘子看成的总体需要先移动到B柱子上，以便于最底下的(最大的)
那1个盘子移动到C柱子上。
故B柱子此时是目标柱子，C柱子是中间柱子。从初始柱子A经过中间柱子C移动到
目标柱子B。
2.对于下面的这1个盘子需要移动到C柱子上。
故C柱子此时是目标柱子，B柱子是中间柱子。看做从初始柱子A不经过中间柱子B
直接移动到目标柱子C，
3.对于n-1个盘子组成的总体，此时这个总体在B柱子上。
故B柱子是这个总体的初始柱子，这个总体最终需要移动到C柱子上，故C柱子此时
便是目标柱子，而A柱子是中间柱子。
看做从初始柱子B经过中间柱子A移动到目标柱子C。

*/

//#include <stdio.h>
//
//void print(char pos1, char pos2);
//void Hanoi(int n, char pos1, char pos2, char pos3);
//
//int main() {
//	int n = 0;
//	scanf("%d", &n);
//
//	Hanoi(n, 'A', 'B', 'C');
//	return 0;
//}
////从pos1柱子移动到pos2柱子
//void print(char pos1, char pos2) {
//	printf("%c->%c ", pos1, pos2);
//}
////
////pos1所在的位置放初始柱子
////pos2所在的位置放中间柱子
////pos3所在的位置放目标柱子
//void Hanoi(int n, char pos1, char pos2, char pos3) {
//	if (n == 1) {
//		print(pos1, pos3);
//	}
//	else {
//		Hanoi(n - 1, pos1, pos3, pos2);
//		print(pos1, pos3);
//		Hanoi(n - 1, pos2, pos1, pos3);
//	}
//}